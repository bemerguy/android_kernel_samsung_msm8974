diff --git a/root/tuned-kernel-LOS14-s5/anykernel_boeffla/tools/ak2-core.sh b/ak3-core.sh
index 28df1ca6881..7b938084e7e 100755
--- a/root/tuned-kernel-LOS14-s5/anykernel_boeffla/tools/ak2-core.sh
+++ b/ak3-core.sh
@@ -1,404 +1,479 @@
-## AnyKernel methods (DO NOT CHANGE)
-#
-# Original and credits: osm0sis @ xda-developers
-#
-# Modified by sunilpaulmathew @ xda-developers.com
-
-# set up extracted files and directories
-ramdisk=/tmp/anykernel/ramdisk;
-bin=/tmp/anykernel/tools;
-split_img=/tmp/anykernel/split_img;
-patch=/tmp/anykernel/patch;
-
-chmod -R 755 $bin;
-mkdir -p $split_img;
-
-FD=$1;
-OUTFD=/proc/self/fd/$FD;
+### AnyKernel methods (DO NOT CHANGE)
+## osm0sis @ xda-developers
+
+OUTFD=$1;
+
+# set up working directory variables
+test "$home" || home=$PWD;
+bootimg=$home/boot.img;
+bin=$home/tools;
+patch=$home/patch;
+ramdisk=$home/ramdisk;
+split_img=$home/split_img;
+
+### output/testing functions:
+# ui_print "<text>" [...]
+ui_print() {
+  until [ ! "$1" ]; do
+    echo -e "ui_print $1
+      ui_print" > /proc/self/fd/$OUTFD;
+    shift;
+  done;
+}
 
-# ui_print <text>
-ui_print() { echo -e "ui_print $1\nui_print" > $OUTFD; }
+# abort ["<text>" [...]]
+abort() {
+  ui_print " " "$@";
+  exit 1;
+}
 
 # contains <string> <substring>
-contains() { test "${1#*$2}" != "$1" && return 0 || return 1; }
+contains() {
+  test "${1#*$2}" != "$1";
+}
 
 # file_getprop <file> <property>
-file_getprop() { grep "^$2=" "$1" | cut -d= -f2; }
+file_getprop() {
+  grep "^$2=" "$1" | cut -d= -f2-;
+}
+###
+
+### file/directory attributes functions:
+# set_perm <owner> <group> <mode> <file> [<file2> ...]
+set_perm() {
+  local uid gid mod;
+  uid=$1; gid=$2; mod=$3;
+  shift 3;
+  chown $uid:$gid "$@" || chown $uid.$gid "$@";
+  chmod $mod "$@";
+}
 
-# reset anykernel directory
-reset_ak() {
-  rm -rf $(dirname /tmp/anykernel/*-files/current)/ramdisk;
-  for i in $ramdisk $split_img /tmp/anykernel/rdtmp /tmp/anykernel/boot.img /tmp/anykernel/*-new*; do
-    cp -af $i $(dirname /tmp/anykernel/*-files/current);
+# set_perm_recursive <owner> <group> <dir_mode> <file_mode> <dir> [<dir2> ...]
+set_perm_recursive() {
+  local uid gid dmod fmod;
+  uid=$1; gid=$2; dmod=$3; fmod=$4;
+  shift 4;
+  while [ "$1" ]; do
+    chown -R $uid:$gid "$1" || chown -R $uid.$gid "$1";
+    find "$1" -type d -exec chmod $dmod {} +;
+    find "$1" -type f -exec chmod $fmod {} +;
+    shift;
   done;
-  rm -rf $ramdisk $split_img $patch /tmp/anykernel/rdtmp /tmp/anykernel/boot.img /tmp/anykernel/*-new* /tmp/anykernel/*-files/current;
-  . /tmp/anykernel/tools/ak2-core.sh $FD;
 }
+###
 
-# dump boot and extract ramdisk
+### dump_boot functions:
+# split_boot (dump and split image only)
 split_boot() {
+  local dumpfail;
+
   if [ ! -e "$(echo $block | cut -d\  -f1)" ]; then
-    ui_print " "; ui_print "Invalid partition. Aborting..."; exit 1;
+    abort "Invalid partition. Aborting...";
+  fi;
+  if [ "$(echo $block | grep ' ')" ]; then
+    block=$(echo $block | cut -d\  -f1);
+    customdd=$(echo $block | cut -d\  -f2-);
+  elif [ ! "$customdd" ]; then
+    local customdd="bs=1048576";
   fi;
   if [ -f "$bin/nanddump" ]; then
-    $bin/nanddump -f /tmp/anykernel/boot.img $block;
+    $bin/nanddump -f $bootimg $block;
   else
-    dd if=$block of=/tmp/anykernel/boot.img;
-  fi;
-  nooktest=$(strings /tmp/anykernel/boot.img | grep -E 'Red Loader|Green Loader|Green Recovery|eMMC boot.img|eMMC recovery.img|BauwksBoot');
-  if [ "$nooktest" ]; then
-    case $nooktest in
-      *BauwksBoot*) nookoff=262144;;
-      *) nookoff=1048576;;
-    esac;
-    mv -f /tmp/anykernel/boot.img /tmp/anykernel/boot-orig.img;
-    dd bs=$nookoff count=1 conv=notrunc if=/tmp/anykernel/boot-orig.img of=$split_img/boot.img-master_boot.key;
-    dd bs=$nookoff skip=1 conv=notrunc if=/tmp/anykernel/boot-orig.img of=/tmp/anykernel/boot.img;
+    dd if=$block of=$bootimg $customdd;
   fi;
-  if [ -f "$bin/unpackelf" -a "$($bin/unpackelf -i /tmp/anykernel/boot.img -h -q 2>/dev/null; echo $?)" == 0 ]; then
+  test $? != 0 && dumpfail=1;
+
+  mkdir -p $split_img;
+  cd $split_img;
+  if [ -f "$bin/unpackelf" ] && $bin/unpackelf -i $bootimg -h -q 2>/dev/null; then
     if [ -f "$bin/elftool" ]; then
-      mkdir $split_img/elftool_out;
-      $bin/elftool unpack -i /tmp/anykernel/boot.img -o $split_img/elftool_out;
-      cp -f $split_img/elftool_out/header $split_img/boot.img-header;
+      mkdir elftool_out;
+      $bin/elftool unpack -i $bootimg -o elftool_out;
     fi;
-    $bin/unpackelf -i /tmp/anykernel/boot.img -o $split_img;
-    mv -f $split_img/boot.img-ramdisk.cpio.gz $split_img/boot.img-ramdisk.gz;
-  elif [ -f "$bin/dumpimage" ]; then
-    $bin/dumpimage -l /tmp/anykernel/boot.img;
-    $bin/dumpimage -l /tmp/anykernel/boot.img > $split_img/boot.img-header;
-    grep "Name:" $split_img/boot.img-header | cut -c15- > $split_img/boot.img-name;
-    grep "Type:" $split_img/boot.img-header | cut -c15- | cut -d\  -f1 > $split_img/boot.img-arch;
-    grep "Type:" $split_img/boot.img-header | cut -c15- | cut -d\  -f2 > $split_img/boot.img-os;
-    grep "Type:" $split_img/boot.img-header | cut -c15- | cut -d\  -f3 | cut -d- -f1 > $split_img/boot.img-type;
-    grep "Type:" $split_img/boot.img-header | cut -d\( -f2 | cut -d\) -f1 | cut -d\  -f1 | cut -d- -f1 > $split_img/boot.img-comp;
-    grep "Address:" $split_img/boot.img-header | cut -c15- > $split_img/boot.img-addr;
-    grep "Point:" $split_img/boot.img-header | cut -c15- > $split_img/boot.img-ep;
-    $bin/dumpimage -i /tmp/anykernel/boot.img -p 0 $split_img/boot.img-zImage;
+    $bin/unpackelf -i $bootimg;
     test $? != 0 && dumpfail=1;
-    if [ "$(cat $split_img/boot.img-type)" == "Multi" ]; then
-      $bin/dumpimage -i /tmp/anykernel/boot.img -p 1 $split_img/boot.img-ramdisk.gz;
+    mv -f boot.img-zImage kernel.gz;
+    mv -f boot.img-ramdisk.cpio.gz ramdisk.cpio.gz;
+    mv -f boot.img-cmdline cmdline.txt 2>/dev/null;
+    if [ -f boot.img-dt -a ! -f "$bin/elftool" ]; then
+      case $(od -ta -An -N4 boot.img-dt | sed -e 's/ del//' -e 's/   //g') in
+        QCDT|ELF) mv -f boot.img-dt dt;;
+        *)
+          gzip -c kernel.gz > kernel.gz-dtb;
+          cat boot.img-dt >> kernel.gz-dtb;
+          rm -f boot.img-dt kernel.gz;
+        ;;
+      esac;
     fi;
+  elif [ -f "$bin/mboot" ]; then
+    $bin/mboot -u -f $bootimg;
+  elif [ -f "$bin/dumpimage" ]; then
+    dd bs=$(($(printf '%d\n' 0x$(hexdump -n 4 -s 12 -e '16/1 "%02x""\n"' $bootimg)) + 64)) count=1 conv=notrunc if=$bootimg of=boot-trimmed.img;
+    $bin/dumpimage -l boot-trimmed.img > header;
+    grep "Name:" header | cut -c15- > boot.img-name;
+    grep "Type:" header | cut -c15- | cut -d\  -f1 > boot.img-arch;
+    grep "Type:" header | cut -c15- | cut -d\  -f2 > boot.img-os;
+    grep "Type:" header | cut -c15- | cut -d\  -f3 | cut -d- -f1 > boot.img-type;
+    grep "Type:" header | cut -d\( -f2 | cut -d\) -f1 | cut -d\  -f1 | cut -d- -f1 > boot.img-comp;
+    grep "Address:" header | cut -c15- > boot.img-addr;
+    grep "Point:" header | cut -c15- > boot.img-ep;
+    $bin/dumpimage -p 0 -o kernel.gz boot-trimmed.img;
     test $? != 0 && dumpfail=1;
+    case $(cat boot.img-type) in
+      Multi) $bin/dumpimage -p 1 -o ramdisk.cpio.gz boot-trimmed.img;;
+      RAMDisk) mv -f kernel.gz ramdisk.cpio.gz;;
+    esac;
   elif [ -f "$bin/rkcrc" ]; then
-    dd bs=4096 skip=8 iflag=skip_bytes conv=notrunc if=/tmp/anykernel/boot.img of=$split_img/boot.img-ramdisk.gz;
-  elif [ -f "$bin/pxa-unpackbootimg" ]; then
-    $bin/pxa-unpackbootimg -i /tmp/anykernel/boot.img -o $split_img;
+    dd bs=4096 skip=8 iflag=skip_bytes conv=notrunc if=$bootimg of=ramdisk.cpio.gz;
   else
-    $bin/unpackbootimg -i /tmp/anykernel/boot.img -o $split_img;
+    $bin/magiskboot unpack -h $bootimg;
+    case $? in
+      1) dumpfail=1;;
+      2) touch chromeos;;
+    esac;
   fi;
+
   if [ $? != 0 -o "$dumpfail" ]; then
-    ui_print " "; ui_print "Dumping/splitting image failed. Aborting..."; exit 1;
-  fi;
-  if [ -f "$bin/unpackelf" -a -f "$split_img/boot.img-dtb" ]; then
-    case $(od -ta -An -N4 $split_img/boot.img-dtb | sed -e 's/del //' -e 's/   //g') in
-      QCDT|ELF) ;;
-      *) gzip $split_img/boot.img-zImage;
-         mv -f $split_img/boot.img-zImage.gz $split_img/boot.img-zImage;
-         cat $split_img/boot.img-dtb >> $split_img/boot.img-zImage;
-         rm -f $split_img/boot.img-dtb;;
-    esac;
+    abort "Dumping/splitting image failed. Aborting...";
   fi;
+  cd $home;
 }
+
+# unpack_ramdisk (extract ramdisk only)
 unpack_ramdisk() {
-  if [ -f "$bin/mkmtkhdr" ]; then
-    dd bs=512 skip=1 conv=notrunc if=$split_img/boot.img-ramdisk.gz of=$split_img/temprd;
-    mv -f $split_img/temprd $split_img/boot.img-ramdisk.gz;
-  fi;
-  mv -f $ramdisk /tmp/anykernel/rdtmp;
-  case $(od -ta -An -N4 $split_img/boot.img-ramdisk.gz) in
-    '  us  vt'*|'  us  rs'*) compext="gz"; unpackcmd="gzip";;
-    '  ht   L   Z   O') compext="lzo"; unpackcmd="lzop";;
-    '   ] nul nul nul') compext="lzma"; unpackcmd="$bin/xz";;
-    '   }   7   z   X') compext="xz"; unpackcmd="$bin/xz";;
-    '   B   Z   h'*) compext="bz2"; unpackcmd="bzip2";;
-    ' stx   !   L can') compext="lz4-l"; unpackcmd="$bin/lz4";;
-    ' etx   !   L can'|' eot   "   M can') compext="lz4"; unpackcmd="$bin/lz4";;
-    *) ui_print " "; ui_print "Unknown ramdisk compression. Aborting..."; exit 1;;
-  esac;
-  mv -f $split_img/boot.img-ramdisk.gz $split_img/boot.img-ramdisk.cpio.$compext;
-  mkdir -p $ramdisk;
-  chmod 755 $ramdisk;
-  cd $ramdisk;
-  $unpackcmd -dc $split_img/boot.img-ramdisk.cpio.$compext | EXTRACT_UNSAFE_SYMLINKS=1 cpio -i -d;
-  if [ $? != 0 -o -z "$(ls $ramdisk)" ]; then
-    ui_print " "; ui_print "Unpacking ramdisk failed. Aborting..."; exit 1;
-  fi;
+  local comp;
 
-	if [ -f $ramdisk/boeffla-anykernel ]; then
-			ui_print "  Installing over existing Boeffla Anykernel...";
-			ui_print " ";
-	fi
+  cd $split_img;
+  if [ -f ramdisk.cpio.gz ]; then
+    if [ -f "$bin/mkmtkhdr" ]; then
+      mv -f ramdisk.cpio.gz ramdisk.cpio.gz-mtk;
+      dd bs=512 skip=1 conv=notrunc if=ramdisk.cpio.gz-mtk of=ramdisk.cpio.gz;
+    fi;
+    mv -f ramdisk.cpio.gz ramdisk.cpio;
+  fi;
 
-	if [ -d $ramdisk/su ]; then
-			ui_print "  SuperSu systemless detected...";
-			ui_print " ";
+  if [ -f ramdisk.cpio ]; then
+    comp=$($bin/magiskboot decompress ramdisk.cpio 2>&1 | grep -v 'raw' | sed -n 's;.*\[\(.*\)\];\1;p');
+  else
+    abort "No ramdisk found to unpack. Aborting...";
+  fi;
+  if [ "$comp" ]; then
+    mv -f ramdisk.cpio ramdisk.cpio.$comp;
+    $bin/magiskboot decompress ramdisk.cpio.$comp ramdisk.cpio;
+    if [ $? != 0 ]; then
+      echo "Attempting ramdisk unpack with busybox $comp..." >&2;
+      $comp -dc ramdisk.cpio.$comp > ramdisk.cpio;
+    fi;
+  fi;
 
-			SAVE_IFS=$IFS;
-			IFS=";"
-			for filename in $supersu_exclusions; do 
-				rm -f /tmp/anykernel/rdtmp/$filename
-			done
-			IFS=$SAVE_IFS;
-	fi;
+  test -d $ramdisk && mv -f $ramdisk $home/rdtmp;
+  mkdir -p $ramdisk;
+  chmod -R 777 $ramdisk;
 
-  test ! -z "$(ls /tmp/anykernel/rdtmp)" && cp -af /tmp/anykernel/rdtmp/* $ramdisk;
+  cd $ramdisk;
+  EXTRACT_UNSAFE_SYMLINKS=1 cpio -d -F $split_img/ramdisk.cpio -i;
+  if [ $? != 0 -o ! "$(ls)" ]; then
+    abort "Unpacking ramdisk failed. Aborting...";
+  fi;
+  if [ -d "$home/rdtmp" ]; then
+    cp -af $home/rdtmp/* .;
+  fi;
 }
+### dump_boot (dump and split image, then extract ramdisk)
 dump_boot() {
   split_boot;
   unpack_ramdisk;
 }
+###
 
-# repack ramdisk then build and write image
+### write_boot functions:
+# repack_ramdisk (repack ramdisk only)
 repack_ramdisk() {
+  local comp packfail mtktype;
+
+  cd $home;
   case $ramdisk_compression in
-    auto|"") compext=`echo $split_img/*-ramdisk.cpio.* | rev | cut -d. -f1 | rev`;;
-    *) compext=$ramdisk_compression;;
-  esac;
-  case $compext in
-    gz) repackcmd="gzip";;
-    lzo) repackcmd="lzo";;
-    lzma) repackcmd="$bin/xz -Flzma";;
-    xz) repackcmd="$bin/xz -Ccrc32";;
-    bz2) repackcmd="bzip2";;
-    lz4-l) repackcmd="$bin/lz4 -l";;
-    lz4) repackcmd="$bin/lz4";;
+    auto|"") comp=$(ls $split_img/ramdisk.cpio.* 2>/dev/null | grep -v 'mtk' | rev | cut -d. -f1 | rev);;
+    none|cpio) comp="";;
+    gz) comp=gzip;;
+    lzo) comp=lzop;;
+    bz2) comp=bzip2;;
+    lz4-l) comp=lz4_legacy;;
+    *) comp=$ramdisk_compression;;
   esac;
+
   if [ -f "$bin/mkbootfs" ]; then
-    $bin/mkbootfs $ramdisk | $repackcmd -9c > /tmp/anykernel/ramdisk-new.cpio.$compext;
+    $bin/mkbootfs $ramdisk > ramdisk-new.cpio;
   else
     cd $ramdisk;
-    find . | cpio -H newc -o | $repackcmd -9c > /tmp/anykernel/ramdisk-new.cpio.$compext;
+    find . | cpio -H newc -o > $home/ramdisk-new.cpio;
   fi;
-  if [ $? != 0 ]; then
-    ui_print " "; ui_print "Repacking ramdisk failed. Aborting..."; exit 1;
+  test $? != 0 && packfail=1;
+
+  cd $home;
+  $bin/magiskboot cpio ramdisk-new.cpio test;
+  magisk_patched=$?;
+  test $((magisk_patched & 3)) -eq 1 && $bin/magiskboot cpio ramdisk-new.cpio "extract .backup/.magisk $split_img/.magisk";
+  if [ "$comp" ]; then
+    $bin/magiskboot compress=$comp ramdisk-new.cpio;
+    if [ $? != 0 ]; then
+      echo "Attempting ramdisk repack with busybox $comp..." >&2;
+      $comp -9c ramdisk-new.cpio > ramdisk-new.cpio.$comp;
+      test $? != 0 && packfail=1;
+      rm -f ramdisk-new.cpio;
+    fi;
   fi;
-  cd /tmp/anykernel;
-  if [ -f "$bin/mkmtkhdr" ]; then
-    $bin/mkmtkhdr --rootfs ramdisk-new.cpio.$compext;
-    mv -f ramdisk-new.cpio.$compext-mtk ramdisk-new.cpio.$compext;
+  if [ "$packfail" ]; then
+    abort "Repacking ramdisk failed. Aborting...";
+  fi;
+
+  if [ -f "$bin/mkmtkhdr" -a -f "$split_img/boot.img-base" ]; then
+    mtktype=$(od -ta -An -N8 -j8 $split_img/ramdisk.cpio.gz-mtk | sed -e 's/ nul//g' -e 's/   //g' | tr '[:upper:]' '[:lower:]');
+    case $mtktype in
+      rootfs|recovery) $bin/mkmtkhdr --$mtktype ramdisk-new.cpio*;;
+    esac;
   fi;
 }
+
+# flash_boot (build, sign and write image only)
 flash_boot() {
+  local varlist i kernel ramdisk fdt cmdline comp part0 part1 nocompflag signfail pk8 cert avbtype;
+
   cd $split_img;
   if [ -f "$bin/mkimage" ]; then
-    name=`cat *-name`;
-    arch=`cat *-arch`;
-    os=`cat *-os`;
-    type=`cat *-type`;
-    comp=`cat *-comp`;
-    test "$comp" == "uncompressed" && comp=none;
-    addr=`cat *-addr`;
-    ep=`cat *-ep`;
-  else
-    if [ -f *-cmdline ]; then
-      cmdline=`cat *-cmdline`;
-      cmd="$split_img/boot.img-cmdline@cmdline";
-    fi;
-    if [ -f *-board ]; then
-      board=`cat *-board`;
-    fi;
-    base=`cat *-base`;
-    pagesize=`cat *-pagesize`;
-    kerneloff=`cat *-kerneloff`;
-    ramdiskoff=`cat *-ramdiskoff`;
-    if [ -f *-tagsoff ]; then
-      tagsoff=`cat *-tagsoff`;
-    fi;
-    if [ -f *-osversion ]; then
-      osver=`cat *-osversion`;
-    fi;
-    if [ -f *-oslevel ]; then
-      oslvl=`cat *-oslevel`;
+    varlist="name arch os type comp addr ep";
+  elif [ -f "$bin/mkbootimg" -a -f "$bin/unpackelf" -a -f boot.img-base ]; then
+    mv -f cmdline.txt boot.img-cmdline 2>/dev/null;
+    varlist="cmdline base pagesize kerneloff ramdiskoff tagsoff";
+  fi;
+  for i in $varlist; do
+    if [ -f boot.img-$i ]; then
+      eval local $i=\"$(cat boot.img-$i)\";
     fi;
-    if [ -f *-second ]; then
-      second=`ls *-second`;
-      second="--second $split_img/$second";
-      secondoff=`cat *-secondoff`;
-      secondoff="--second_offset $secondoff";
-    fi;
-    if [ -f *-hash ]; then
-      hash=`cat *-hash`;
-      test "$hash" == "unknown" && hash=sha1;
-      hash="--hash $hash";
-    fi;
-    if [ -f *-unknown ]; then
-      unknown=`cat *-unknown`;
-    fi;
-  fi;
-  for i in zImage zImage-dtb Image.gz Image Image-dtb Image.gz-dtb Image.bz2 Image.bz2-dtb Image.lzo Image.lzo-dtb Image.lzma Image.lzma-dtb Image.xz Image.xz-dtb Image.lz4 Image.lz4-dtb Image.fit; do
-    if [ -f /tmp/anykernel/$i ]; then
-      kernel=/tmp/anykernel/$i;
+  done;
+
+  cd $home;
+  for i in zImage zImage-dtb Image Image-dtb Image.gz Image.gz-dtb Image.bz2 Image.bz2-dtb Image.lzo Image.lzo-dtb Image.lzma Image.lzma-dtb Image.xz Image.xz-dtb Image.lz4 Image.lz4-dtb Image.fit; do
+    if [ -f $i ]; then
+      kernel=$home/$i;
       break;
     fi;
   done;
-  if [ ! "$kernel" ]; then
-    kernel=`ls *-zImage`;
-    kernel=$split_img/$kernel;
+  if [ "$kernel" ]; then
+    if [ -f "$bin/mkmtkhdr" -a -f "$split_img/boot.img-base" ]; then
+      $bin/mkmtkhdr --kernel $kernel;
+      kernel=$kernel-mtk;
+    fi;
+  elif [ "$(ls $split_img/kernel* 2>/dev/null)" ]; then
+    kernel=$(ls $split_img/kernel* | grep -v 'kernel_dtb' | tail -n1);
   fi;
-  if [ -f /tmp/anykernel/ramdisk-new.cpio.$compext ]; then
-    rd=/tmp/anykernel/ramdisk-new.cpio.$compext;
+  if [ "$(ls ramdisk-new.cpio* 2>/dev/null)" ]; then
+    ramdisk=$home/$(ls ramdisk-new.cpio* | tail -n1);
+  elif [ -f "$bin/mkmtkhdr" -a -f "$split_img/boot.img-base" ]; then
+    ramdisk=$split_img/ramdisk.cpio.gz-mtk;
   else
-    rd=`ls *-ramdisk.*`;
-    rd="$split_img/$rd";
+    ramdisk=$(ls $split_img/ramdisk.cpio* 2>/dev/null | tail -n1);
   fi;
-  for i in dtb dt.img; do
-    if [ -f /tmp/anykernel/$i ]; then
-      dtb="--dt /tmp/anykernel/$i";
-      rpm="/tmp/anykernel/$i,rpm";
-      break;
-    fi;
+  for fdt in dt recovery_dtbo dtb; do
+    for i in $home/$fdt $home/$fdt.img $split_img/$fdt; do
+      if [ -f $i ]; then
+        eval local $fdt=$i;
+        break;
+      fi;
+    done;
   done;
-  if [ ! "$dtb" -a -f *-dtb ]; then
-    dtb=`ls *-dtb`;
-    rpm="$split_img/$dtb,rpm";
-    dtb="--dt $split_img/$dtb";
-  fi;
-  cd /tmp/anykernel;
-  if [ -f "$bin/mkmtkhdr" ]; then
-    case $kernel in
-      $split_img/*) ;;
-      *) $bin/mkmtkhdr --kernel $kernel; kernel=$kernel-mtk;;
-    esac;
-  fi;
+
+  cd $split_img;
   if [ -f "$bin/mkimage" ]; then
-    test "$type" == "Multi" && uramdisk=":$rd";
-    $bin/mkimage -A $arch -O $os -T $type -C $comp -a $addr -e $ep -n "$name" -d $kernel$uramdisk boot-new.img;
+    test "$comp" == "uncompressed" && comp=none;
+    part0=$kernel;
+    case $type in
+      Multi) part1=":$ramdisk";;
+      RAMDisk) part0=$ramdisk;;
+    esac;
+    $bin/mkimage -A $arch -O $os -T $type -C $comp -a $addr -e $ep -n "$name" -d $part0$part1 $home/boot-new.img;
   elif [ -f "$bin/elftool" ]; then
-    $bin/elftool pack -o boot-new.img header=$split_img/boot.img-header $kernel $rd,ramdisk $rpm $cmd;
+    test "$dt" && dt="$dt,rpm";
+    test -f cmdline.txt && cmdline="cmdline.txt@cmdline";
+    $bin/elftool pack -o $home/boot-new.img header=elftool_out/header $kernel $ramdisk,ramdisk $dt $cmdline;
+  elif [ -f "$bin/mboot" ]; then
+    cp -f $kernel kernel;
+    cp -f $ramdisk ramdisk.cpio.gz;
+    $bin/mboot -d $split_img -f $home/boot-new.img;
   elif [ -f "$bin/rkcrc" ]; then
-    $bin/rkcrc -k $rd boot-new.img;
-  elif [ -f "$bin/pxa-mkbootimg" ]; then
-    $bin/pxa-mkbootimg --kernel $kernel --ramdisk $rd $second --cmdline "$cmdline" --board "$board" --base $base --pagesize $pagesize --kernel_offset $kerneloff --ramdisk_offset $ramdiskoff $secondoff --tags_offset "$tagsoff" --unknown $unknown $dtb --output boot-new.img;
+    $bin/rkcrc -k $ramdisk $home/boot-new.img;
+  elif [ -f "$bin/mkbootimg" -a -f "$bin/unpackelf" -a -f boot.img-base ]; then
+    test "$dt" && dt="--dt $dt";
+    $bin/mkbootimg --kernel $kernel --ramdisk $ramdisk --cmdline "$cmdline" --base $home --pagesize $pagesize --kernel_offset $kerneloff --ramdisk_offset $ramdiskoff --tags_offset "$tagsoff" $dt --output $home/boot-new.img;
   else
-    $bin/mkbootimg --kernel $kernel --ramdisk $rd $second --cmdline "$cmdline" --board "$board" --base $base --pagesize $pagesize --kernel_offset $kerneloff --ramdisk_offset $ramdiskoff $secondoff --tags_offset "$tagsoff" --os_version "$osver" --os_patch_level "$oslvl" $hash $dtb --output boot-new.img;
+    test "$kernel" && cp -f $kernel kernel;
+    test "$ramdisk" && cp -f $ramdisk ramdisk.cpio;
+    test "$dt" -a -f extra && cp -f $dt extra;
+    for i in dtb recovery_dtbo; do
+      test "$(eval echo \$$i)" -a -f $i && cp -f $(eval echo \$$i) $i;
+    done;
+    case $kernel in
+      *Image*)
+        if [ ! "$magisk_patched" ]; then
+          $bin/magiskboot cpio ramdisk.cpio test;
+          magisk_patched=$?;
+        fi;
+        if [ $((magisk_patched & 3)) -eq 1 ]; then
+          ui_print " " "Magisk detected! Patching kernel so reflashing Magisk is not necessary...";
+          comp=$($bin/magiskboot decompress kernel 2>&1 | grep -v 'raw' | sed -n 's;.*\[\(.*\)\];\1;p');
+          ($bin/magiskboot split $kernel || $bin/magiskboot decompress $kernel kernel) 2>/dev/null;
+          if [ $? != 0 -a "$comp" ]; then
+            echo "Attempting kernel unpack with busybox $comp..." >&2;
+            $comp -dc $kernel > kernel;
+          fi;
+          $bin/magiskboot hexpatch kernel 736B69705F696E697472616D667300 77616E745F696E697472616D667300;
+          if [ "$(file_getprop $home/anykernel.sh do.systemless)" == 1 ]; then
+            strings kernel | grep -E 'Linux version.*#' > $home/vertmp;
+          fi;
+          if [ "$comp" ]; then
+            $bin/magiskboot compress=$comp kernel kernel.$comp;
+            if [ $? != 0 ]; then
+              echo "Attempting kernel repack with busybox $comp..." >&2;
+              $comp -9c kernel > kernel.$comp;
+            fi;
+            mv -f kernel.$comp kernel;
+          fi;
+          test ! -f .magisk && $bin/magiskboot cpio ramdisk.cpio "extract .backup/.magisk .magisk";
+          export $(cat .magisk);
+          test $((magisk_patched & 8)) -ne 0 && export TWOSTAGEINIT=true;
+          for fdt in dtb extra kernel_dtb recovery_dtbo; do
+            test -f $fdt && $bin/magiskboot dtb $fdt patch;
+          done;
+        else
+          case $kernel in
+            *-dtb) rm -f kernel_dtb;;
+          esac;
+        fi;
+        unset magisk_patched KEEPFORCEENCRYPT KEEPVERITY SHA1 TWOSTAGEINIT;
+      ;;
+    esac;
+    case $ramdisk_compression in
+      none|cpio) nocompflag="-n";;
+    esac;
+    $bin/magiskboot repack $nocompflag $bootimg $home/boot-new.img;
   fi;
   if [ $? != 0 ]; then
-    ui_print " "; ui_print "Repacking image failed. Aborting..."; exit 1;
+    abort "Repacking image failed. Aborting...";
   fi;
+
+  cd $home;
   if [ -f "$bin/futility" -a -d "$bin/chromeos" ]; then
-    $bin/futility vbutil_kernel --pack boot-new-signed.img --keyblock $bin/chromeos/kernel.keyblock --signprivate $bin/chromeos/kernel_data_key.vbprivk --version 1 --vmlinuz boot-new.img --bootloader $bin/chromeos/empty --config $bin/chromeos/empty --arch arm --flags 0x1;
-    if [ $? != 0 ]; then
-      ui_print " "; ui_print "Signing image failed. Aborting..."; exit 1;
+    if [ -f "$split_img/chromeos" ]; then
+      echo "Signing with CHROMEOS..." >&2;
+      $bin/futility vbutil_kernel --pack boot-new-signed.img --keyblock $bin/chromeos/kernel.keyblock --signprivate $bin/chromeos/kernel_data_key.vbprivk --version 1 --vmlinuz boot-new.img --bootloader $bin/chromeos/empty --config $bin/chromeos/empty --arch arm --flags 0x1;
     fi;
-    mv -f boot-new-signed.img boot-new.img;
+    test $? != 0 && signfail=1;
   fi;
   if [ -f "$bin/BootSignature_Android.jar" -a -d "$bin/avb" ]; then
-    if [ -f "/system/system/bin/dalvikvm" ]; then
-      umount /system;
-      umount /system 2>/dev/null;
-      mkdir /system_root;
-      mount -o ro -t auto /dev/block/bootdevice/by-name/system$slot /system_root;
-      mount -o bind /system_root/system /system;
-    fi;
-    pk8=`ls $bin/avb/*.pk8`;
-    cert=`ls $bin/avb/*.x509.*`;
+    pk8=$(ls $bin/avb/*.pk8);
+    cert=$(ls $bin/avb/*.x509.*);
     case $block in
       *recovery*|*SOS*) avbtype=recovery;;
       *) avbtype=boot;;
     esac;
-    savedpath="$LD_LIBRARY_PATH";
-    unset LD_LIBRARY_PATH;
-    if [ "$(/system/bin/dalvikvm -Xbootclasspath:/system/framework/core-oj.jar:/system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/bouncycastle.jar -Xnodex2oat -Xnoimage-dex2oat -cp $bin/BootSignature_Android.jar com.android.verity.BootSignature -verify boot.img 2>&1 | grep VALID)" ]; then
-      /system/bin/dalvikvm -Xbootclasspath:/system/framework/core-oj.jar:/system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/bouncycastle.jar -Xnodex2oat -Xnoimage-dex2oat -cp $bin/BootSignature_Android.jar com.android.verity.BootSignature /$avbtype boot-new.img $pk8 $cert boot-new-signed.img;
-      if [ $? != 0 ]; then
-        ui_print " "; ui_print "Signing image failed. Aborting..."; exit 1;
-      fi;
-    fi;
-    test "$savedpath" && export LD_LIBRARY_PATH="$savedpath";
-    mv -f boot-new-signed.img boot-new.img;
-    if [ -d "/system_root" ]; then
-      umount /system;
-      umount /system_root;
-      rmdir /system_root;
-      mount -o ro -t auto /system;
+    if [ "$(/system/bin/dalvikvm -Xnoimage-dex2oat -cp $bin/BootSignature_Android.jar com.android.verity.BootSignature -verify boot.img 2>&1 | grep VALID)" ]; then
+      echo "Signing with AVBv1..." >&2;
+      /system/bin/dalvikvm -Xnoimage-dex2oat -cp $bin/BootSignature_Android.jar com.android.verity.BootSignature /$avbtype boot-new.img $pk8 $cert boot-new-signed.img;
     fi;
   fi;
-  if [ -f "$bin/blobpack" ]; then
-    printf '-SIGNED-BY-SIGNBLOB-\00\00\00\00\00\00\00\00' > boot-new-signed.img;
-    $bin/blobpack tempblob LNX boot-new.img;
-    cat tempblob >> boot-new-signed.img;
-    mv -f boot-new-signed.img boot-new.img;
+  if [ $? != 0 -o "$signfail" ]; then
+    abort "Signing image failed. Aborting...";
   fi;
-  if [ -f "/data/custom_boot_image_patch.sh" ]; then
-    ash /data/custom_boot_image_patch.sh /tmp/anykernel/boot-new.img;
-    if [ $? != 0 ]; then
-      ui_print " "; ui_print "User script execution failed. Aborting..."; exit 1;
-    fi;
-  fi;
-    if [ $add_seandroidenforce == "1" ]; then
-      echo -n "SEANDROIDENFORCE" >> /tmp/anykernel/boot-new.img
-    fi
-  if [ -f "$bin/dhtbsign" ]; then
-    $bin/dhtbsign -i boot-new.img -o boot-new-signed.img;
-    mv -f boot-new-signed.img boot-new.img;
-  fi;
-  if [ -f "$split_img/boot.img-master_boot.key" ]; then
-    cat $split_img/boot.img-master_boot.key boot-new.img > boot-new-signed.img;
-    mv -f boot-new-signed.img boot-new.img;
-  fi;
-  if [ ! -f /tmp/anykernel/boot-new.img ]; then
-    ui_print " "; ui_print "Repacked image could not be found. Aborting..."; exit 1;
+  mv -f boot-new-signed.img boot-new.img 2>/dev/null;
+
+  if [ ! -f boot-new.img ]; then
+    abort "No repacked image found to flash. Aborting...";
   elif [ "$(wc -c < boot-new.img)" -gt "$(wc -c < boot.img)" ]; then
-    ui_print " "; ui_print "New image larger than boot partition. Aborting..."; exit 1;
+    abort "New image larger than boot partition. Aborting...";
   fi;
   if [ -f "$bin/flash_erase" -a -f "$bin/nandwrite" ]; then
     $bin/flash_erase $block 0 0;
-    $bin/nandwrite -p $block /tmp/anykernel/boot-new.img;
+    $bin/nandwrite -p $block boot-new.img;
+  elif [ "$customdd" ]; then
+    dd if=/dev/zero of=$block $customdd 2>/dev/null;
+    dd if=boot-new.img of=$block $customdd;
   else
-    dd if=/dev/zero of=$block 2>/dev/null;
-    dd if=/tmp/anykernel/boot-new.img of=$block;
+    cat boot-new.img /dev/zero > $block 2>/dev/null || true;
   fi;
+  if [ $? != 0 ]; then
+    abort "Flashing image failed. Aborting...";
+  fi;
+}
+
+# flash_dtbo (flash dtbo only)
+flash_dtbo() {
+  local i dtbo dtboblock;
+
+  cd $home;
   for i in dtbo dtbo.img; do
-    if [ -f /tmp/anykernel/$i ]; then
+    if [ -f $i ]; then
       dtbo=$i;
       break;
     fi;
   done;
+
   if [ "$dtbo" ]; then
-    dtbo_block=`find /dev/block -iname dtbo$slot | head -n 1` 2>/dev/null;
-    [ ! -z $dtbo_block ] && dtbo_block=`readlink -f $dtbo_block`
-    if [ ! -e "$(echo $dtbo_block)" ]; then
-      ui_print " "; ui_print "dtbo partition could not be found. Aborting..."; exit 1;
+    dtboblock=/dev/block/bootdevice/by-name/dtbo$slot;
+    if [ ! -e "$dtboblock" ]; then
+      abort "dtbo partition could not be found. Aborting...";
     fi;
     if [ -f "$bin/flash_erase" -a -f "$bin/nandwrite" ]; then
-      $bin/flash_erase $dtbo_block 0 0;
-      $bin/nandwrite -p $dtbo_block /tmp/anykernel/$dtbo;
+      $bin/flash_erase $dtboblock 0 0;
+      $bin/nandwrite -p $dtboblock $dtbo;
+    elif [ "$customdd" ]; then
+      dd if=/dev/zero of=$dtboblock 2>/dev/null;
+      dd if=$dtbo of=$dtboblock;
     else
-      dd if=/dev/zero of=$dtbo_block 2>/dev/null;
-      dd if=/tmp/anykernel/$dtbo of=$dtbo_block;
+      cat $dtbo /dev/zero > $dtboblock 2>/dev/null || true;
+    fi;
+    if [ $? != 0 ]; then
+      abort "Flashing dtbo failed. Aborting...";
     fi;
   fi;
 }
+### write_boot (repack ramdisk then build, sign and write image and dtbo)
 write_boot() {
   repack_ramdisk;
   flash_boot;
+  flash_dtbo;
 }
+###
 
+### file editing functions:
 # backup_file <file>
-backup_file() { test ! -f $1~ && cp $1 $1~; }
+backup_file() { test ! -f $1~ && cp -fp $1 $1~; }
 
 # restore_file <file>
-restore_file() { test -f $1~ && mv -f $1~ $1; }
+restore_file() { test -f $1~ && cp -fp $1~ $1; rm -f $1~; }
 
-# replace_string <file> <if search string> <original string> <replacement string>
+# replace_string <file> <if search string> <original string> <replacement string> <scope>
 replace_string() {
-  if [ -z "$(grep "$2" $1)" ]; then
-      sed -i "s;${3};${4};" $1;
+  test "$5" == "global" && local scope=g;
+  if ! grep -q "$2" $1; then
+    sed -i "s;${3};${4};${scope}" $1;
   fi;
 }
 
 # replace_section <file> <begin search string> <end search string> <replacement string>
 replace_section() {
-  begin=`grep -n "$2" $1 | head -n1 | cut -d: -f1`;
+  local begin endstr last end;
+  begin=$(grep -n "$2" $1 | head -n1 | cut -d: -f1);
   if [ "$begin" ]; then
-    test "$3" == " " -o -z "$3" && endstr='^$' || endstr="$3";
-    for end in `grep -n "$endstr" $1 | cut -d: -f1`; do
+    if [ "$3" == " " -o ! "$3" ]; then
+      endstr='^[[:space:]]*$';
+      last=$(wc -l $1 | cut -d\  -f1);
+    else
+      endstr="$3";
+    fi;
+    for end in $(grep -n "$endstr" $1 | cut -d: -f1) $last; do
       if [ "$end" ] && [ "$begin" -lt "$end" ]; then
-        if [ "$3" == " " -o -z "$3" ]; then
-          sed -i "/${2//\//\\/}/,/^\s*$/d" $1;
-        else
-          sed -i "/${2//\//\\/}/,/${3//\//\\/}/d" $1;
-        fi;
+        sed -i "${begin},${end}d" $1;
+        test "$end" == "$last" && echo >> $1;
         sed -i "${begin}s;^;${4}\n;" $1;
         break;
       fi;
@@ -408,16 +483,18 @@ replace_section() {
 
 # remove_section <file> <begin search string> <end search string>
 remove_section() {
-  begin=`grep -n "$2" $1 | head -n1 | cut -d: -f1`;
+  local begin endstr last end;
+  begin=$(grep -n "$2" $1 | head -n1 | cut -d: -f1);
   if [ "$begin" ]; then
-    test "$3" == " " -o -z "$3" && endstr='^$' || endstr="$3";
-    for end in `grep -n "$endstr" $1 | cut -d: -f1`; do
+    if [ "$3" == " " -o ! "$3" ]; then
+      endstr='^[[:space:]]*$';
+      last=$(wc -l $1 | cut -d\  -f1);
+    else
+      endstr="$3";
+    fi;
+    for end in $(grep -n "$endstr" $1 | cut -d: -f1) $last; do
       if [ "$end" ] && [ "$begin" -lt "$end" ]; then
-        if [ "$3" == " " -o -z "$3" ]; then
-          sed -i "/${2//\//\\/}/,/^\s*$/d" $1;
-        else
-          sed -i "/${2//\//\\/}/,/${3//\//\\/}/d" $1;
-        fi;
+        sed -i "${begin},${end}d" $1;
         break;
       fi;
     done;
@@ -426,7 +503,8 @@ remove_section() {
 
 # insert_line <file> <if search string> <before|after> <line match string> <inserted line>
 insert_line() {
-  if [ -z "$(grep "$2" $1)" ]; then
+  local offset line;
+  if ! grep -q "$2" $1; then
     case $3 in
       before) offset=0;;
       after) offset=1;;
@@ -442,30 +520,31 @@ insert_line() {
 
 # replace_line <file> <line replace string> <replacement line>
 replace_line() {
-  if [ ! -z "$(grep "$2" $1)" ]; then
-    line=`grep -n "$2" $1 | head -n1 | cut -d: -f1`;
+  if grep -q "$2" $1; then
+    local line=$(grep -n "$2" $1 | head -n1 | cut -d: -f1);
     sed -i "${line}s;.*;${3};" $1;
   fi;
 }
 
 # remove_line <file> <line match string>
 remove_line() {
-  if [ ! -z "$(grep "$2" $1)" ]; then
-    line=`grep -n "$2" $1 | head -n1 | cut -d: -f1`;
+  if grep -q "$2" $1; then
+    local line=$(grep -n "$2" $1 | head -n1 | cut -d: -f1);
     sed -i "${line}d" $1;
   fi;
 }
 
 # prepend_file <file> <if search string> <patch file>
 prepend_file() {
-  if [ -z "$(grep "$2" $1)" ]; then
+  if ! grep -q "$2" $1; then
     echo "$(cat $patch/$3 $1)" > $1;
   fi;
 }
 
 # insert_file <file> <if search string> <before|after> <line match string> <patch file>
 insert_file() {
-  if [ -z "$(grep "$2" $1)" ]; then
+  local offset line;
+  if ! grep -q "$2" $1; then
     case $3 in
       before) offset=0;;
       after) offset=1;;
@@ -478,7 +557,7 @@ insert_file() {
 
 # append_file <file> <if search string> <patch file>
 append_file() {
-  if [ -z "$(grep "$2" $1)" ]; then
+  if ! grep -q "$2" $1; then
     echo -ne "\n" >> $1;
     cat $patch/$3 >> $1;
     echo -ne "\n" >> $1;
@@ -491,10 +570,11 @@ replace_file() {
   chmod $2 $1;
 }
 
-# patch_fstab <fstab file> <mount match name> <fs match type> <block|mount|fstype|options|flags> <original string> <replacement string>
+# patch_fstab <fstab file> <mount match name> <fs match type> block|mount|fstype|options|flags <original string> <replacement string>
 patch_fstab() {
+  local entry part newpart newentry;
   entry=$(grep "$2" $1 | grep "$3");
-  if [ -z "$(echo "$entry" | grep "$6")" -o "$6" == " " -o -z "$6" ]; then
+  if [ ! "$(echo "$entry" | grep "$6")" -o "$6" == " " -o ! "$6" ]; then
     case $4 in
       block) part=$(echo "$entry" | awk '{ print $1 }');;
       mount) part=$(echo "$entry" | awk '{ print $2 }');;
@@ -510,54 +590,172 @@ patch_fstab() {
 
 # patch_cmdline <cmdline entry name> <replacement string>
 patch_cmdline() {
-  cmdfile=`ls $split_img/*-cmdline`;
-  if [ -z "$(grep "$1" $cmdfile)" ]; then
-    cmdtmp=`cat $cmdfile`;
+  local cmdfile cmdtmp match;
+  if [ -f "$split_img/cmdline.txt" ]; then
+    cmdfile=$split_img/cmdline.txt;
+  else
+    cmdfile=$home/cmdtmp;
+    grep "^cmdline=" $split_img/header | cut -d= -f2- > $cmdfile;
+  fi;
+  if ! grep -q "$1" $cmdfile; then
+    cmdtmp=$(cat $cmdfile);
     echo "$cmdtmp $2" > $cmdfile;
     sed -i -e 's;  *; ;g' -e 's;[ \t]*$;;' $cmdfile;
   else
     match=$(grep -o "$1.*$" $cmdfile | cut -d\  -f1);
     sed -i -e "s;${match};${2};" -e 's;  *; ;g' -e 's;[ \t]*$;;' $cmdfile;
   fi;
+  if [ -f "$home/cmdtmp" ]; then
+    sed -i "s|^cmdline=.*|cmdline=$(cat $cmdfile)|" $split_img/header;
+    rm -f $cmdfile;
+  fi;
 }
 
 # patch_prop <prop file> <prop name> <new prop value>
 patch_prop() {
-  if [ -z "$(grep "^$2=" $1)" ]; then
+  if ! grep -q "^$2=" $1; then
     echo -ne "\n$2=$3\n" >> $1;
   else
-    line=`grep -n "^$2=" $1 | head -n1 | cut -d: -f1`;
+    local line=$(grep -n "^$2=" $1 | head -n1 | cut -d: -f1);
     sed -i "${line}s;.*;${2}=${3};" $1;
   fi;
 }
 
-# allow multi-partition ramdisk modifying configurations (using reset_ak)
-if [ ! -d "$ramdisk" -a ! -d "$patch" ]; then
-  if [ -d "$(basename $block)-files" ]; then
-    cp -af /tmp/anykernel/$(basename $block)-files/* /tmp/anykernel;
+# patch_ueventd <ueventd file> <device node> <permissions> <chown> <chgrp>
+patch_ueventd() {
+  local file dev perm user group newentry line;
+  file=$1; dev=$2; perm=$3; user=$4;
+  shift 4;
+  group="$@";
+  newentry=$(printf "%-23s   %-4s   %-8s   %s\n" "$dev" "$perm" "$user" "$group");
+  line=$(grep -n "$dev" $file | head -n1 | cut -d: -f1);
+  if [ "$line" ]; then
+    sed -i "${line}s;.*;${newentry};" $file;
   else
-    mkdir -p /tmp/anykernel/$(basename $block)-files;
+    echo -ne "\n$newentry\n" >> $file;
   fi;
-  touch /tmp/anykernel/$(basename $block)-files/current;
-fi;
-test ! -d "$ramdisk" && mkdir -p $ramdisk;
+}
+###
 
-# slot detection enabled by is_slot_device=1 (from anykernel.sh)
-if [ "$is_slot_device" == 1 -o "$is_slot_device" == "auto" ]; then
-  slot=$(getprop ro.boot.slot_suffix 2>/dev/null);
-  test ! "$slot" && slot=$(grep -o 'androidboot.slot_suffix=.*$' /proc/cmdline | cut -d\  -f1 | cut -d= -f2);
-  if [ ! "$slot" ]; then
-    slot=$(getprop ro.boot.slot 2>/dev/null);
-    test ! "$slot" && slot=$(grep -o 'androidboot.slot=.*$' /proc/cmdline | cut -d\  -f1 | cut -d= -f2);
-    test "$slot" && slot=_$slot;
-  fi;
-  if [ "$slot" ]; then
-    test -e "$block$slot" && block=$block$slot;
+### configuration/setup functions:
+# reset_ak [keep]
+reset_ak() {
+  local current i;
+
+  current=$(dirname $home/*-files/current);
+  if [ -d "$current" ]; then
+    rm -rf $current/ramdisk;
+    for i in $bootimg boot-new.img; do
+      test -e $i && cp -af $i $current;
+    done;
   fi;
-  if [ $? != 0 -a "$is_slot_device" == 1 ]; then
-    ui_print " "; ui_print "Unable to determine active boot slot. Aborting..."; exit 1;
+  test -d $split_img && rm -rf $ramdisk;
+  rm -rf $bootimg $split_img $home/*-new* $home/*-files/current;
+
+  if [ "$1" == "keep" ]; then
+    test -d $home/rdtmp && mv -f $home/rdtmp $ramdisk;
+  else
+    rm -rf $patch $home/rdtmp;
   fi;
-fi;
+  setup_ak;
+}
+
+# setup_ak
+setup_ak() {
+  local blockfiles parttype name part mtdmount mtdpart mtdname target;
+
+  # allow multi-partition ramdisk modifying configurations (using reset_ak)
+  if [ "$block" ] && [ ! -d "$ramdisk" -a ! -d "$patch" ]; then
+    blockfiles=$home/$(basename $block)-files;
+    if [ "$(ls $blockfiles 2>/dev/null)" ]; then
+      cp -af $blockfiles/* $home;
+    else
+      mkdir -p $blockfiles;
+    fi;
+    touch $blockfiles/current;
+  fi;
+
+  # slot detection enabled by is_slot_device=1 or auto (from anykernel.sh)
+  case $is_slot_device in
+    1|auto)
+      slot=$(getprop ro.boot.slot_suffix 2>/dev/null);
+      test "$slot" || slot=$(grep -o 'androidboot.slot_suffix=.*$' /proc/cmdline | cut -d\  -f1 | cut -d= -f2);
+      if [ ! "$slot" ]; then
+        slot=$(getprop ro.boot.slot 2>/dev/null);
+        test "$slot" || slot=$(grep -o 'androidboot.slot=.*$' /proc/cmdline | cut -d\  -f1 | cut -d= -f2);
+        test "$slot" && slot=_$slot;
+      fi;
+      if [ "$slot" ]; then
+        if [ -d /postinstall/tmp -a ! "$slot_select" ]; then
+          slot_select=inactive;
+        fi;
+        case $slot_select in
+          inactive)
+            case $slot in
+              _a) slot=_b;;
+              _b) slot=_a;;
+            esac;
+          ;;
+        esac;
+      fi;
+      if [ ! "$slot" -a "$is_slot_device" == 1 ]; then
+        abort "Unable to determine active boot slot. Aborting...";
+      fi;
+    ;;
+  esac;
+
+  # target block partition detection enabled by block=boot recovery or auto (from anykernel.sh)
+  case $block in
+     auto|"") block=boot;;
+  esac;
+  case $block in
+    boot|recovery)
+      case $block in
+        boot) parttype="ramdisk boot BOOT LNX android_boot bootimg KERN-A kernel KERNEL";;
+        recovery) parttype="ramdisk_recovery recovery RECOVERY SOS android_recovery";;
+      esac;
+      for name in $parttype; do
+        for part in $name$slot $name; do
+          if [ "$(grep -w "$part" /proc/mtd 2> /dev/null)" ]; then
+            mtdmount=$(grep -w "$part" /proc/mtd);
+            mtdpart=$(echo $mtdmount | cut -d\" -f2);
+            if [ "$mtdpart" == "$part" ]; then
+              mtdname=$(echo $mtdmount | cut -d: -f1);
+            else
+              abort "Unable to determine mtd $block partition. Aborting...";
+            fi;
+            if [ -e /dev/mtd/$mtdname ]; then
+              target=/dev/mtd/$mtdname;
+            fi;
+          elif [ -e /dev/block/by-name/$part ]; then
+            target=/dev/block/by-name/$part;
+          elif [ -e /dev/block/bootdevice/by-name/$part ]; then
+            target=/dev/block/bootdevice/by-name/$part;
+          elif [ -e /dev/block/platform/*/by-name/$part ]; then
+            target=/dev/block/platform/*/by-name/$part;
+          elif [ -e /dev/block/platform/*/*/by-name/$part ]; then
+            target=/dev/block/platform/*/*/by-name/$part;
+          elif [ -e /dev/$part ]; then
+            target=/dev/$part;
+          fi;
+          test "$target" && break 2;
+        done;
+      done;
+      if [ "$target" ]; then
+        block=$(ls $target 2>/dev/null);
+      else
+        abort "Unable to determine $block partition. Aborting...";
+      fi;
+    ;;
+    *)
+      if [ "$slot" ]; then
+        test -e "$block$slot" && block=$block$slot;
+      fi;
+    ;;
+  esac;
+}
+###
 
-## end methods
+### end methods
 
+setup_ak;
